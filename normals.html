<html>
<head>
  <script type="text/javascript" src="webgl-utils.js"></script>
  <script type="text/javascript" src="fboTextureUtils.js"></script>
  <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7/jquery.min.js"></script>
<style type="text/css"></style></head>

<body style="padding: 0px; margin: 0px;" cz-shortcut-listen="true">
<div id="container">
	  <canvas id="canvas" style="background:black; position:absolute;top:0;left:0;z-index:0; width:100%; height:100%;" width="1439" height="695">
      Sorry but your browser doesn't support the canvas :(
    </canvas>
  </div>


<script id="baseVs" type="x-shader/x-vertex">
//attributes come from fboTextureUtils
attribute vec3 pos;
attribute vec4 color;
attribute vec2 texcoord;

varying vec2 v_texCoord;
varying vec4 vColor;

void main() {
   gl_Position = vec4(pos.x,pos.y,pos.z,1.0);
   v_texCoord = texcoord;
   vColor = color;
}
</script>


<script id="baseFs" type="x-shader/x-fragment">
precision mediump float;
uniform sampler2D u_image; 
uniform sampler2D u_image2; 
uniform sampler2D u_image3; 
uniform float time; // seconds
varying vec2 v_texCoord;
uniform vec2 res;
float hash( float n )
{
    return fract(sin(n)*43758.5453);
}
float noise( in vec3 x )
{
    vec3 p = floor(x);
    vec3 f = fract(x);

    f = f*f*(3.0-2.0*f);
    float n = p.x + p.y*57.0 + 113.0*p.z;
    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),
                   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),
               mix(mix( hash(n+113.0), hash(n+114.0),f.x),
                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);
}

//x3
vec3 noise3( in vec3 x)
{
  return vec3( noise(x+vec3(123.456,.567,.37)),
        noise(x+vec3(.11,47.43,19.17)),
        noise(x) );
}

//http://dept-info.labri.fr/~schlick/DOC/gem2.ps.gz
float bias(float x, float b) {
  return  x/((1./b-2.)*(1.-x)+1.);
}

float gain(float x, float g) {
  float t = (1./g-2.)*(1.-(2.*x));  
  return x<0.5 ? (x/(t+1.)) : (t-x)/(t-1.);
}


mat3 rotation(float angle, vec3 axis)
{
    float s = sin(-angle);
    float c = cos(-angle);
    float oc = 1.0 - c;
  vec3 sa = axis * s;
  vec3 oca = axis * oc;
    return mat3(  
    oca.x * axis + vec3(  c,  -sa.z,  sa.y),
    oca.y * axis + vec3( sa.z,  c,    -sa.x),   
    oca.z * axis + vec3(-sa.y,  sa.x, c));  
}

vec3 fbm(vec3 x, float H, float L, int oc)
{
  vec3 v = vec3(0);
  float f = 1.;
  for (int i=0; i<10; i++)
  {
    if (i >= oc) break;
    float w = pow(f,-H);
    v += noise3(x)*w;
    x *= L;
    f *= L;
  }
  return v;
}

vec3 smf(vec3 x, float H, float L, int oc, float off)
{
  vec3 v = vec3(1);
  float f = 1.;
  for (int i=0; i<10; i++)
  {
    if (i >= oc) break;
    v *= off + f*(noise3(x)*2.-1.);
    f *= H;
    x *= L;
  }
  return v; 
}


void main(void)
{

  
  // float time = time * 1.276;
  
  float slow = time*0.06;
  //uv *= 1. + .5*slow*sin(slow*10.);
            
  vec3 p = vec3(v_texCoord*0.5,slow);         //coordinate + slight change over time
  
  vec3 axis = 5. * fbm(texture2D(u_image,v_texCoord).rgb*0.5, 0.5, 2., 8);        //random fbm axis of rotation
  
  vec3 colorVec =  0.5* 5. * fbm(p*0.3,0.5,2.,7);   //random base color
  p += colorVec;
  
//  float mag = 4e5;  //published, rather garish?
  float mag = 0.75e5; //still clips a bit
//  mag = mag * (1.+sin(2.*3.1415927*ts)*0.75);
  // vec3 colorMod = mag * smf(p,0.7,2.,8,.2);     //multifractal saturation
  // colorVec += colorMod;
  
  colorVec = rotation(3.*length(axis)+slow*10.,normalize(axis))*colorVec;
  
  colorVec *= 0.05;
      
//  colorVec = colorVec / (1. + length(colorVec));  //tone it all down a bit
  
  colorVec = pow(colorVec,vec3(1./2.2));    //gamma
  // vec3 tex0 = ((colorVec+texture2D(u_image,v_texCoord).rgb)*0.5);
  gl_FragColor = vec4(colorVec,1.0);
}

</script>


<script id="feedbackFs" type="x-shader/x-fragment">
precision mediump float;
uniform sampler2D u_image;
uniform vec2 res;
varying vec2 v_texCoord;
const float stepSize = 1.0;

void main() {

  vec2 res2 = res * 0.55;

  vec2 offset = vec2(stepSize/res.x, stepSize/res.y);
  vec2 sharpenOffset = vec2(stepSize/res2.x, stepSize/res2.y);
  vec4 color = texture2D(u_image, v_texCoord);

  //blur
  color += texture2D(u_image, vec2(v_texCoord.x - offset.x, v_texCoord.y)); //left
  color += texture2D(u_image, vec2(v_texCoord.x + offset.x, v_texCoord.y)); //right
  color += texture2D(u_image, vec2(v_texCoord.x + offset.x, v_texCoord.y + offset.y)); //bottom right
  color += texture2D(u_image, vec2(v_texCoord.x + offset.x, v_texCoord.y - offset.y)); //top right
  color += texture2D(u_image, vec2(v_texCoord.x, v_texCoord.y - offset.x)); //bottom
  color += texture2D(u_image, vec2(v_texCoord.x, v_texCoord.y + offset.y)); //top
  color += texture2D(u_image, vec2(v_texCoord.x - offset.x, v_texCoord.y + offset.y)); //bottom left
  color += texture2D(u_image, vec2(v_texCoord.x - offset.x, v_texCoord.y - offset.y)); //top left

  color /= 8.0;

  //emboss or sharpen
  color += texture2D(u_image, vec2(v_texCoord.x, v_texCoord.y - sharpenOffset.x)); //bottom
  color -= texture2D(u_image, vec2(v_texCoord.x, v_texCoord.y + sharpenOffset.y*-2.5)); //top

  //reduce color if all white
  float avg = (color.r+color.g+color.b)/3.0;
  color = avg > 0.95 ? color-0.15 : color;

  gl_FragColor = color ;
}
</script>


<script id="colorFrag" type="x-shader/x-fragment">
precision mediump float;
uniform sampler2D u_image;
uniform vec2 mouse;
uniform float time;
varying vec2 v_texCoord;
uniform int index;
uniform vec2 res;

vec2 texelWidth = 1.0/res; 

void main() {
    
    vec4 input0 = texture2D(u_image,v_texCoord);


    float step = 3.0;
    float tl = abs(texture2D(u_image, v_texCoord + texelWidth * vec2(-step, -step)).x);   // top left
    float  l = abs(texture2D(u_image, v_texCoord + texelWidth * vec2(-step,  0.0)).x);   // left
    float bl = abs(texture2D(u_image, v_texCoord + texelWidth * vec2(-step,  step)).x);   // bottom left
    float  t = abs(texture2D(u_image, v_texCoord + texelWidth * vec2( 0.0, -step)).x);   // top
    float  b = abs(texture2D(u_image, v_texCoord + texelWidth * vec2( 0.0,  step)).x);   // bottom
    float tr = abs(texture2D(u_image, v_texCoord + texelWidth * vec2( step, -step)).x);   // top right
    float  r = abs(texture2D(u_image, v_texCoord + texelWidth * vec2( step,  0.0)).x);   // right
    float br = abs(texture2D(u_image, v_texCoord + texelWidth * vec2( step,  step)).x);   // bottom right

    float mult = 0.01;

    float dX = tr*mult + 2.0*r*mult + br*mult -tl*mult - 2.0*l*mult - bl*mult;
    float dY = bl*mult + 2.0*b*mult + br*mult -tl*mult - 2.0*t*mult - tr*mult;
    

    vec4 diffuseColor = texture2D(u_image, v_texCoord);

    vec3 color = normalize(vec3(dX,dY,1.0/3.0));
    
    for( int i = 0; i<4; i++){
      color +=color;
    }

    vec3 lightDir = vec3( vec2( mouse.x/res.x, 1.0-mouse.y/res.y)-(gl_FragCoord.xy / vec2(res.x,res.y)), 3.75 );
    lightDir.x *= res.x/res.y;

    float D = length(lightDir);

    vec3 N = normalize(color);
    vec3 L = normalize(lightDir);
    vec3 H = normalize(L);

    vec4 lightColor = input0;
    vec4 ambientColor = vec4(vec3(input0.rgb),0.5);
    
    vec3 falloff = vec3(1.0,3.0,20.5);
  
    vec3 diffuse = (lightColor.rgb * lightColor.a) * max(dot(N, L), 0.0);
    vec3 ambient = ambientColor.rgb * ambientColor.a;
    
    float shin = 300.1;
    float sf = max(0.0,dot(N,H));
    sf = pow(sf, shin);
  
    float attenuation = 1.0 / (falloff.x + (falloff.y*D) + (falloff.z * D * D) );

    vec3 intensity =  ambient+(diffuse+sf ) * attenuation;
    vec3 finalColor = (diffuseColor.rgb * intensity);

    vec3 col = ambient+( finalColor+sf );

    color *=0.5;
    color +=0.5;

    vec4 C = index == 0 ? vec4(col, 1.0) : vec4(color, 1.0);
    gl_FragColor = C;
}
</script>


<script type="text/javascript">
var gl, baseTexture, canvas, fbo, feedback, bb;
var baseProgram, feedbackProgram, colorProgram;
var baseVs, baseFs, feedbackFs, colorFs;
var camTex;
var mouseX, mouseY;
var videoLoaded = false;
var firstFrame = true;
var delay = 0;
var time = 0;
var index = 0, normalMode = false;

var video=document.createElement('video');

canvas = document.getElementById("canvas");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

document.addEventListener('mousedown', onDocumentMouseDown, false);
document.addEventListener('mousemove', onDocumentMouseMove, false);

initGl();
initFbosAndShaders();
getCamAsTexture();
loop();


function initGl(){
  gl = getWebGLContext(canvas);
}

function initFbosAndShaders(){
  baseTexture = new pxBB();
  fbo = new pxFbo();
  feedback = new pxFbo();

  //set up fbo's
  fbo.allocate(canvas.width, canvas.height);
  feedback.allocate(canvas.width, canvas.height);

  //create shaders
  baseVs = createShaderFromScriptElement(gl, "baseVs");
  baseFs = createShaderFromScriptElement(gl, "baseFs");
  feedbackFs = createShaderFromScriptElement(gl, "feedbackFs");
  colorFs = createShaderFromScriptElement(gl, "colorFrag");
  //create program
  baseProgram = createProgram(gl, [baseVs, baseFs]);
  feedbackProgram = createProgram(gl, [baseVs, feedbackFs]);
  colorProgram = createProgram(gl, [baseVs, colorFs]);
}


function loop(){
window.requestAnimationFrame(loop);
time += 0.1;

if(videoLoaded){

  if(delay < 50){
    getNewImg();
    delay++;
  }

 if(normalMode){
  index = 1;
 }
 else if(!normalMode){
  index = 0;
 }
  gl.useProgram(baseProgram);
  gl.uniform1f(gl.getUniformLocation(baseProgram,"time"), time);
 fbo.start();
  gl.useProgram(colorProgram);
  gl.uniform2f(gl.getUniformLocation(colorProgram,"res"), canvas.width, canvas.height);
  gl.uniform2f(gl.getUniformLocation(colorProgram,"mouse"), mouseX, mouseY);
  gl.uniform1f(gl.getUniformLocation(colorProgram,"time"), time);
  gl.uniform1i(gl.getUniformLocation(colorProgram,"index"), index);
  baseTexture.draw(colorProgram, camTex);




 //calling bindFramebuffer with null will draw to the screen
 gl.bindFramebuffer(gl.FRAMEBUFFER, null);
 fbo.draw(baseProgram);

 //keep updating camtex in case we want another frame
 gl.bindTexture(gl.TEXTURE_2D, camTex);
 gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, camTex.image);
}//end of videoLoaded 
}


function getCamAsTexture(){
  //create camera texture
  camTex = createAndSetupTexture(gl);
  camTex.image = video;

  gl.bindTexture(gl.TEXTURE_2D, camTex);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, camTex.image);

}

function getNewImg(){
   //gets a new frame
   

   fbo.start();
   baseTexture.draw(baseProgram, camTex);
}


function onDocumentMouseDown(event) {
    normalMode = !normalMode;
    console.log(index);
    getNewImg();
}


function onDocumentMouseMove(event) {
    mouseX = (event.clientX );
    mouseY = (event.clientY );
}

//capture video
  window.addEventListener('DOMContentLoaded', function(){
        navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia;
 
    if (navigator.getUserMedia) {       
        navigator.getUserMedia({video: true, audio: false}, handleVideo, videoError);
    }
 
    function handleVideo(stream) {
      var url = window.URL || window.webkitURL;
       video.src = url ? url.createObjectURL(stream) : stream;
        video.play();
        //video.src = window.URL.createObjectURL(stream);
        videoLoaded = true;
    }
 
    function videoError(e) {
      alert("There seems to be something wrong with your webcam. Closing any other webcam apps and then restart your browser.");
    }
  });

</script>


</body></html>